## 1.  개요

MySQL BY 8.0.42 ver.

`접속 #1 : docker exec -it system-modeling-1-mysql bash`

`접속 #2 : mysql -u root -p`

- 본 프로젝트를 통해 무결한 Data-modeling을 전제로 하여 시스템 모델링으로 이어지는 전략, 그 중 데이터베이스 설계에 대해 집중적으로 분석한다.
- 일전과 마찬가지로 이론에 그치지 않고 실무 활용, 이와 관련한 깊이 있는 고민을 통해 즉각 실무 적용이 가능할 정도로 역량을 보완하도록 한다.

구체적인 내용은 벨로그 통해 기술, 기술적인 내용들은 아래 내용으로 간략하게 기재.

## 2. 시스템 모델링 - 데이터베이스 설계

> 개념적 모델링 - 논리적 모델링 - 물리적 모델링까지 이어진다.

[벨로그 기술에 자세한 내용 기술](https://velog.io/@gyrbs22/%EB%B0%B1%EC%97%94%EB%93%9C-Database-3-%EC%A0%95%EB%B3%B4%EB%A5%BC-%ED%91%9C%ED%98%84%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95%EC%9D%84-%EA%B3%A0%EB%AF%BC%ED%95%98%EB%8B%A4-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%AA%A8%EB%8D%B8%EB%A7%81%EB%B3%B8%EC%A7%88%ED%8E%B8-%ED%99%95%EC%9E%A5-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%84%A4%EA%B3%84%EC%9D%98-3%EB%8B%A8%EA%B3%84)

### 2-1.개념적 모델링 : 엔티티 별 ERD 산출

> 데이터를 표현하고 이의 관계를 ERD를 통해 나타낸다.

key point : 엔티티 구성 및 분류
- 형태 유무에 따른 유형엔티티, 무형엔티티
  - 무형 엔티티는 비즈니스 행위에 필요한 개념 엔티티, 비즈니스 행위의 결과인 사건(이벤트) 엔티티
- 비즈니스 처리 흐름에 따른 기본엔티티, 중심엔티티, 행위엔티티
  - 기본엔티티와 중심엔티티는 각각 정보성 데이터, 원장 데이터, 행위엔티티는 로그성 데이터 
- 관계 기반에 따라 식별 관계의 강한 엔티티, 약한 엔티티 혹은 비식별 관계로 분류
- 관계가 행위에 종속될 경우 연관 엔티티, 엔티티의 특성을 계층적으로 나타낸다면 슈퍼타입/서브엔티티로 분류

엔티티 분류 작업 이후에 인덱스 생성 및 데이터 파티셔닝/아키이빙 등의 추가 전략 구성 필요.

> 기본/중심 엔티티 1차 도출 후 관계성/비즈니스 행위에 기반한 연관 엔티티를 통해 2차 정규화 진행.

key point : 카디널리티 및 참여도 정의와 연관 엔티티를 통한 다대다 관계 해소
- 연결관계(카디널리티)와 참여도를 정의하여 엔티티 간의 관계를 세부적으로 정의한다.
- 이후 산출된 다대다 엔티티에 대해서는 관계 기반의 연관 엔티티를 적극 활용하여 다대다 관계를 해소한다.
- 용어사전을 운용하여 모델링 운용의 효율성을 제고하고 일관성을 확보한다.
- 엔티티의 관계 정도(결합도 및 종속성)에 대해 정의한다.

## 2-2. 논리적 모델링 : 테이블 스키마 산출

> 테이블의 PK를 설정하고, FK를 통해 테이블 간의 연결관계를 구체화하고, 이를 기반으로 스키마를 추출한다.
> From to,
> - 엔티티 > Table
> - 속성 > 컬럼
> - 식별자 > PK
> - 카디널리티 및 참여도(연결관계) > FK + Constraint (*식별관계 및 비식별관계로의 구체화)
> - 누락사항 발생 시 추가적인 관계성 도출

key point : 불변하는 자연키는 존재하지 않으며, 인조키 설정으로 인한 성능 트레이드 오프를 고려해야 하다.
- 자연키 설정의 경우, 비즈니스에 종속적이기에 대표성은 가지지만 불변하지 않고, 변경점 발생 시 대응에 취약.
  - 자연키가 실무에서 빈번히 발생하는 조회속성 및 정렬순서가 다르다면 PK 정렬에 수반되는 비용 발생
- 인조키(대리키) 설정의 경우, 비즈니스와 테이블의 관계를 완벽하게 분리하고 본연의 목적을 수행하기 위해 인조적으로 생성.
  - 클러스터링 인덱스가 존재하더라도, 조회 성능 향상을 위한 추가 인덱스 설계가 반드시 필요

> 관계성은 비즈니스적으로 가지는 엔티티 간의 관계와, 1 row가 의미하는 기록/유형의 의미를 정확히 파악하는 데에서 비롯한다.
- 연관엔티티 등 관계성이 모호하다면 그 테이블의 1row가 가지는 의미, 형태, 유형 등을 정확히 이해해보도록 하자.

> 성능적 장단점이 존재하더라도, 대리키가 가져다주는 이점이 확실하기에 대리키(PK)-자연키(UNIQUE) 조합을 강력하게 권장.
- 변경사항이 빈번하게 바뀌는 현대 애플리케이션 특성 상, 직관성/편의성에서 안정성/유연성/확장성으로 관리 패러다임이 변경되었다.
- 시스템 모델링 및 MSA에서의 분산환경으로의 변경점이 그대로 전파되어, 대리키의 중요도는 그만큼 높아졌다.

> 자연키의 문제점은 복합키의 설정으로 이어질 수 있고, 모델링 및 데이터 조합 시 번거로움, 물리적 비용이 그만큼 증가한다.
- 단순하게 대리키 하나를 지정하고, 해당 자연키를 UNIQUE하게 지정하여 안정성/확장성/인덱스 추가 설계 등의 성능 및 구조적 장점을 확보할 수 있다.
- 데이터 관리 - 대리키 1개로 단순화, 비즈니스의 속성/고유성 보장 - UNIQUE 제약조건 설정

> 유지보수, 확장성 관점에서 카디널리티를 설정하고 구체화한다.
- 개념적 모델링에서 정의한 관계의 강도를 논리적 모델링 단계에서 구체화하고 강한 엔티티 기반의 관계로 바꾼다.
  - 식별관계의 종속적 관계에서 비식별관계의 독립적 엔티티/테이블 정체성으로 변경하도록 한다.
- 1:1
  - 하나의 테이블에 통합하는 것보다는, 페이지 분할 및 단편화 등 성능적 관점에서 1:1 분리가 유리할 수 있다.
  - 중심/행위 등 비즈니스 관점에서 도메인을 분리하고, 기준이 되는 주 테이블과 보조 테이블을 분리
  - 분리 후, OCP 원칙에 근거하여 참조 관계를 명확하게 정의하며 확장성에 유리한 방향으로 PK/FK 지정 필요

[참고 : 주테이블의 관계가 역전되어 외래키를 주테이블에 지정해야 하는 상황]

주 테이블과 보조 테이블의 관계역전은 결국 테이블 간의 관계 변경을 의미한다.
  - 주 테이블 보다 보조 테이블의 참여도가 필수일 경우
  - 비정규화를 의도적으로 진행하여, 테이블의 물리적/구조적 모순보다 조회 성능이 훨씬 중요할 경우
    - JOIN을 최소화하고자 할 경우
  - ORM을 의도한 편의성을 확보할 경우

주 테이블과 보조 테이블 관계에 입각한 상식적인 테이블 설계를 우선적으로 고려하고 진행하자.
</br>
테이블 관계 역전으로 인한 PK/FK 관리비용은 인덱스 설계 등을 통한 성능개선 및 튜닝이 훨씬 영향도가 높다.

- M:N
  - 관계형 데이터베이스에서 물리적, 이론적으로 하나의 행에 여러 데이터가 존재할 수 없다.
  - 다대다 관계는 존재 불가, 반드시 1:N 관계로 해소해야 한다.

[연관 엔티티]
- 단순히 다대다 관계를 해소하는 도구가 아닌, 두 엔티티 간의 비즈니스 행위에 대한 결과로 생각해야 한다.
- 비즈니스에서 발생하는 관계와 의미를 파악하고, 이를 통해 의미있는 정보를 연관 엔티티의 속성으로 구체화한다.

## 2-3. 물리적 모델링 : 데이터베이스에 적용 가능한 물리적 형태 명확화 : 물리적인 테이블 및 데이터 생성

> ERD를 데이터베이스 종속적인 형태로 구체화, 물리화한다.

- 특정 DBMS를 채택한다.
- 이를 기반으로 데이터 형태/인덱스/데이터 파티셔닝/성능 튜닝 등 물리적 스키마를 정의하고 최종적으로 구현한다.
- 엔티티는 릴레이션(테이블), 속성은 컬럼, 이외 제약조건 설정 등 진행.

[명명일관성]
- 용어사전에 근거한 명확하고 일관된 단어와 개념을 사용한다.

[데이터 무결성 확보를 위한 적절한 데이터 타입 선정]
- 주문ID = bigint(100만건 기준 int 대비 38MB, 76MB 차이로 거의 미비한 수준)
- 회원ID/재고수량 = int(최대 21억까지 저장)
- boolean = tinyint 혹은 boolean
- 돈 관련 = 정수형태(double, decimal과 같은 실수형태 금지)
- 날짜 = datetime(timestamp의 경우 시간대 변환 제약이 존재하여 YYYYMMDD HH:MI:SS 형태로 지정하는 것이 안전)

## 3. 정규화

> 빠른 구축을 위한 의도적인 비정규화, 테이블 통합? 이것은 희생이 아닌 "주먹구구식" 개발일 뿐이다.
- 성능적, 구조적 이점을 모두 포기하고 빠른 구축과 단순 명료한 시스템 개발은 대책없는 개발 그 이상, 그 이하도 아니다.
- 초기 설계단계부터 막무가내 식 모델링이 아닌, 튼튼한 기본기를 바탕으로 유연한 대응이 가능한, 온전하고 안전한 설계와 모델링이 우선적으로 고려되어야 한다.
- 테이블의 구조와 성능 간 트레이드 오프를 고려하는 것은 온전한 설계를 마친 이후에 해도 늦지않다.

**논리적 모델링에서 테이블 관계를 정의하고 이를 다듬는 과정인 정규화는 이러한 데이터 모델링의 기본 과정이다.**
- 데이터 중복 제거 및 일관성, 무결성 확보
- 견고하면서도 유연한 데이터 모델링

> 정규화의 기본 : 함수 종속성
- 비즈니스 행위 혹은 결과를 데이터베이스의 데이터 모델링을 통해 표현한다.
- 이러한 데이터 표현은 더이상 논리적으로 분리할 수 없고, 1개의 PK가 다른 원자적인 데이터 집합을 유일하게 구분한다.

> 제1정규형 : 원자성(Atomic)
- 1 row = 1 record = 논리적으로 더이상 분해할 수 없는 단위이다.
- 한 컬럼에 같은 의미를 지닌 동일한 형태의 데이터가 중복될 수 없고, 다른 의미를 지닌 상이한 형태의 데이터가 동시에 나타날 수 없다.
  - 옵티마이저의 실행계획 논리가 무너지며, 정상적인 검색과 조회 성능 보장이 불가능하다.
  - 수정 자체가 복잡해지며, 삽입, 삭제 시 무결성을 보장하기 어렵고 불가능하다.
  - 다른 형태의 데이터가 들어가 있을 경우 테이블 간의 관계 정의가 불가능하다.

> 제2정규형
- 자연키 기반의 복합키 구성과 논리적 모델링 단계에서 데이터 튜플이 복합키의 일부가 아닌 전체에 의해 일관되게 결정이 된다.
  - 즉, PK에 의한 완전한 종속관계, 즉 완전 함수 종속을 만족한다.
- 쉽게 말하면 도메인을 분리하여 테이블 역시 분리하는 과정이다.

> 제3정규형
- 제2정규형 후 분리한 테이블 내에서 완전 함수 종속이 아닌 이행적 함수 종속 관계가 발생할 경우, 이를 단일 종속관계로 변환하는 과정이다.
- 제2정규형과 마찬가지로 테이블을 분리하는 과정이지만, 대리키(단일 기본키) 구성에 적용하는 과정이다.

> BCNF정규형
- 결정자를 지정하고 이를 후보키로 정의하는 과정에서, 모든 결정자는 후보키의 규칙을 만족해야 한다.
  - 제1~제3정규형은 테이블의 릴레이션(1row) 단위로 종속성을 분석하며 도메인을 분리하는 과정이었다면, BCNF 정규형은 행과 행 간의 유일성을 보장하기 위한 과정이다.
  - 실무에서는 제3정규형까지 진행할 경우 대부분 정규형을 만족하지만, 드물게 행 간의 유일성을 보장하지 못하여 BCNF 정규형 만족을 하지 못하는 경우가 발생한다.
- 모든 결정자는 후보키가 되어야 하므로, 행 내부에서의 데이터 간 완전함수종속과 더불어 행과 행 간의 유일성을 보장해야 한다.

## 4. 인덱스

> 선택도(유일성/카디널리티)가 높은 조건을 대상으로 조회성능을 향상시키기 위한 최적화된 인덱스를 설계한다. 
- 기본적으로 EXAPLIN을 통한 실행계획을 분석하자.
  - 원본 테이블 스캔 시 얼마나 많은 테이블 행을 스캔하는지 먼저 파악한다.
    - full table scan의 스캔 수가 수천건 이상이라면 인덱싱 고려할 것.
- UQ, FK는 무결성을 보장하기 위해 자동 인덱스 생성 대상이다.
  - 그만큼 선택도, 필터링 강도가 높은 항목이다.
  - 쓰기 비용에 의한 과잉 최적화 비용을 고려하여, 높은 선택도로 인해 충분한 필터링(수백건)이 이루어진다면 추가 인덱스 생성은 굳이 하지 않아도 된다.
- 인덱스 스캔을 기반으로 한 스캔 대상이 수백 건이지만 filtered 비율이 낮거나 filesort 발생할 경우 치명적인 성능 하락의 원인이 될 수 있다.
  - 이때 복합 인덱스 및 정렬 조건 추가 등을 고려하여 인덱스 추가 최적화 진행.

## 5. 역정규화

정규화로 인한 테이블 분리, 이로 인한 쿼리 복잡도가 증가하고 시스템 전체 성능에 영향을 줄 수 있다.
</br>
이러한 성능 문제를 보완하고자 조회 성능 향상을 위해 필요 항목을 의도적으로 하나의 엔티티, 릴레이션으로 배치하는 과정을 의미한다.

> 명확한 성능 데이터 및 병목 지점을 기반으로 정확한 역정규화 항목을 정의하고 진행한다.
- 데이터의 중복을 의도적으로 허용하여, 일관성 및 정합성을 희생하는 대신 쿼리의 단순화 및 조회성능향상을 확보한다.
- 쓰기 작업 시 갱신이상이 발생할 수 있기에, 쓰기 작업에 대한 제약을 감안한 작업이 필요하다.
- 데이터 중복 허용에 의해 저해된 일관성/정합성을 보장하기 위한 데이터 동기화 작업(로직수정 및 배치 등)을 반드시 수반한다.

[역정규화 기법]
- 중복 컬럼 추가 : 필요한 테이블의 컬럼을 의도적으로 추가한다(회원-주문 개수 등).
- 파생 컬럼 추가 : SUM, AVG의 복잡한 계산 연산을 오래 소모하는 경우 계산 결과를 미리 컬럼에 추가, 저장한다(회원-총 주문 수 등).

[반정규화/역정규화/비정규화]
- 반정규화 : 정규화에 반대하는 개념을 모두 총괄하는 개념.
- 역정규화 : 정규화된 테이블을 조회성능향상의 목적으로 의도적으로 정규화의 반대 방향으로 되돌리는 과정.
- 비정규화 : 정규화를 만족하지 않은 상태, 그러한 과정을 일컫는다.

## 6. 유의사항

> 조회 성능에 대한 트레이드 오프를 고려하는 시점은 데이터를 무결하게 저장하였는가 그 이후에 고민해야 하는 부분이다.

데이터 일관성 보장을 위한 정규화, 테이블 분리는 JOIN 비용 증가, 저장 공간 증가, 성능 저하의 문제를 발생시킬 수 있지만,
</br>
데이터베이스가 가지는 본연의 역할은 데이터의 무결성을 유지하고 관리하는 것에 있다는 점을 명심하자.